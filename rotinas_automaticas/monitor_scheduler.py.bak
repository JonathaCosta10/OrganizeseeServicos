"""
Sistema de Monitoramento e RenovaÃ§Ã£o DiÃ¡ria do Scheduler
===============================        # Agendar tarefas recorrentes
        
        # RenovaÃ§Ã£o diÃ¡ria Ã s 00:01
        schedule.every().day.at("00:01").do(self._renovar_carga_diaria)
        
        # ExecuÃ§Ã£o do scheduler a cada minuto para mais precisÃ£o
        schedule.every(1).minutes.do(self._executar_scheduler_se_necessario)
        
        # VerificaÃ§Ã£o especÃ­fica de rotinas do minuto atual para maior precisÃ£o
        schedule.every(10).seconds.do(self._verificar_execucoes_imediatas)
        
        # VerificaÃ§Ã£o de saÃºde a cada hora
        schedule.every().hour.do(self._verificar_saude_sistema)
        
        logger.info("ðŸ“… Tarefas agendadas:")
        logger.info("   - RenovaÃ§Ã£o diÃ¡ria: 00:01")
        logger.info("   - Scheduler: a cada minuto")
        logger.info("   - VerificaÃ§Ãµes precisas: a cada 10 segundos")
        logger.info("   - VerificaÃ§Ã£o de saÃºde: a cada hora")==========

Pro            # Verificar se hÃ¡ rotinas pendentes para executar
            pendentes = FilaExecucao.objects.filter(
                status='PENDENTE',
                data_execucao__lte=agora.date(),
                horario_execucao__lte=agora.time()
            )
            
            # Listar detalhes das rotinas pendentes
            if pendentes.exists():
                for item in pendentes:
                    nome_rotina = item.scheduler_rotina.rotina_definicao.nome_exibicao
                    logger.info(f"ðŸ“‹ Rotina pendente: {nome_rotina} - HorÃ¡rio: {item.horario_execucao} (atual: {agora.time()})")
            
            total_pendentes = pendentes.count()
            if total_pendentes > 0:
                logger.info(f"ðŸš€ Executando scheduler - {total_pendentes} rotina(s) pendente(s)")
                
                # Executar scheduler
                from rotinas_automaticas.scheduler_services import SchedulerService
                
                scheduler = SchedulerService()
                resultado = scheduler.executor.executar_fila(limite_execucoes=10)
                
                self.ultima_execucao_scheduler = agora
                
                logger.info(f"âœ… Scheduler executado - {resultado['total_executadas']} rotinas processadas")ackground para:
- Monitorar execuÃ§Ã£o das rotinas
- Renovar carga diÃ¡ria Ã s 00:01
- Executar scheduler automaticamente
- Garantir continuidade do sistema

Autor: Sistema Automatizado
Data: 16/09/2025
"""

import os
import sys
import time
import threading
import schedule
from datetime import datetime, timedelta
import pytz
import logging
from django.core.management import call_command
from django.conf import settings

# Configurar timezone
BRAZIL_TZ = pytz.timezone('America/Sao_Paulo')

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('scheduler_monitor')

# Aumentar nÃ­vel de log para DEBUG durante desenvolvimento
logger.setLevel(logging.DEBUG)

class SchedulerMonitor:
    """Monitor do sistema de scheduler"""
    
    def __init__(self):
        self.running = False
        self.thread = None
        self.ultima_execucao_scheduler = None
        self.ultima_renovacao_diaria = None
        
    def start(self):
        """Inicia o monitor"""
        if self.running:
            return
            
        self.running = True
        self.thread = threading.Thread(target=self._run_monitor, daemon=True)
        self.thread.start()
        
        # Agendar tarefas
        self._agendar_tarefas()
        
        logger.info("ðŸ”„ Monitor do scheduler iniciado")
        
    def stop(self):
        """Para o monitor"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=5)
        logger.info("ðŸ›‘ Monitor do scheduler parado")
        
    def _agendar_tarefas(self):
        """Agenda tarefas recorrentes"""
        
        # RenovaÃ§Ã£o diÃ¡ria Ã s 00:01
        schedule.every().day.at("00:01").do(self._renovar_carga_diaria)
        
        # ExecuÃ§Ã£o do scheduler a cada minuto para garantir execuÃ§Ãµes precisas
        schedule.every(1).minutes.do(self._executar_scheduler_se_necessario)
        
        # VerificaÃ§Ã£o de saÃºde a cada hora
        schedule.every().hour.do(self._verificar_saude_sistema)
        
        # VerificaÃ§Ã£o de rotinas travadas a cada 30 minutos
        schedule.every(30).minutes.do(self._verificar_rotinas_travadas)
        
        logger.info("ðŸ“… Tarefas agendadas:")
        logger.info("   - RenovaÃ§Ã£o diÃ¡ria: 00:01")
        logger.info("   - Scheduler: a cada 1 minuto")
        logger.info("   - VerificaÃ§Ã£o saÃºde: a cada hora")
        logger.info("   - VerificaÃ§Ã£o rotinas travadas: a cada 30 minutos")
        
    def _run_monitor(self):
        """Loop principal do monitor"""
        ultima_verificacao = datetime.now(BRAZIL_TZ)
        
        while self.running:
            try:
                # Executar tarefas agendadas
                schedule.run_pending()
                
                # Verificar se hÃ¡ rotinas que deveriam ser executadas neste minuto exato
                # para evitar perder execuÃ§Ãµes devido ao ciclo de sleep
                self._verificar_execucoes_imediatas()
                
                # Registrar tempo de verificaÃ§Ã£o para mÃ©tricas de desempenho
                agora = datetime.now(BRAZIL_TZ)
                delta = (agora - ultima_verificacao).total_seconds()
                if delta > 15:  # Se passou mais de 15 segundos entre verificaÃ§Ãµes
                    logger.warning(f"âš ï¸ Atraso de {delta:.1f}s entre verificaÃ§Ãµes do monitor")
                ultima_verificacao = agora
                
                # Sleep mais curto para garantir execuÃ§Ã£o prÃ³xima ao horÃ¡rio exato
                time.sleep(5)  # Verificar a cada 5 segundos para maior precisÃ£o
            except ConnectionError as e:
                logger.error(f"Erro de conexÃ£o no monitor: {e}", exc_info=True)
                time.sleep(15)  # Aguardar um pouco mais em caso de erro de conexÃ£o
            except Exception as e:
                logger.error(f"Erro no monitor: {e}", exc_info=True)
                time.sleep(10)  # Aguardar menos tempo para nÃ£o perder execuÃ§Ãµes
                
    def _renovar_carga_diaria(self):
        """Executa renovaÃ§Ã£o diÃ¡ria Ã s 00:01"""
        try:
            agora = datetime.now(BRAZIL_TZ)
            logger.info(f"ðŸŒ… Iniciando renovaÃ§Ã£o diÃ¡ria - {agora.strftime('%d/%m/%Y %H:%M:%S')}")
            
            # Importar aqui para evitar problemas de inicializaÃ§Ã£o
            from rotinas_automaticas.startup_scheduler import carregar_rotinas_diarias_startup
            
            # Executar carga diÃ¡ria
            sucesso = carregar_rotinas_diarias_startup()
            
            if sucesso:
                self.ultima_renovacao_diaria = agora
                logger.info("âœ… RenovaÃ§Ã£o diÃ¡ria concluÃ­da com sucesso")
            else:
                logger.error("âŒ Falha na renovaÃ§Ã£o diÃ¡ria")
                
        except Exception as e:
            logger.error(f"Erro na renovaÃ§Ã£o diÃ¡ria: {e}", exc_info=True)
            
    def _executar_scheduler_se_necessario(self):
        """Executa scheduler se houver rotinas pendentes"""
        try:
            inicio_verificacao = datetime.now(BRAZIL_TZ)
            
            # Permitir execuÃ§Ã£o 24 horas por dia para garantir que todas as rotinas sejam executadas
            agora = inicio_verificacao
            
            # Importar modelos
            from rotinas_automaticas.models import FilaExecucao
            
            # Log do horÃ¡rio atual para depuraÃ§Ã£o
            hora_atual_str = agora.strftime('%H:%M:%S')
            logger.debug(f"Monitor verificando rotinas pendentes Ã s {hora_atual_str}")
            
            # Verificar se hÃ¡ rotinas pendentes para executar
            pendentes_query = FilaExecucao.objects.filter(
                status='PENDENTE',
                data_execucao__lte=agora.date(),
                horario_execucao__lte=agora.time()
            )
            
            pendentes_count = pendentes_query.count()
            
            # Verificar tambÃ©m rotinas que estÃ£o prÃ³ximas de executar (1 minuto no mÃ¡ximo)
            proxima_execucao = None
            proximas_rotinas = FilaExecucao.objects.filter(
                status='PENDENTE',
                data_execucao=agora.date(),
            ).order_by('horario_execucao').first()
            
            if proximas_rotinas:
                proxima_execucao = f"{proximas_rotinas.scheduler_rotina.rotina_definicao.nome_exibicao} Ã s {proximas_rotinas.horario_execucao}"
            
            if pendentes_count > 0:
                # Listar as rotinas pendentes detalhadamente para debug
                rotinas_pendentes = []
                for item in pendentes_query:
                    rotina_nome = item.scheduler_rotina.rotina_definicao.nome_exibicao
                    rotinas_pendentes.append(
                        f"{rotina_nome} ({item.data_execucao} {item.horario_execucao})"
                    )
                
                logger.info(f"ðŸš€ Executando scheduler - {pendentes_count} rotina(s) pendente(s): {', '.join(rotinas_pendentes)}")
                
                # Executar scheduler
                from rotinas_automaticas.scheduler_services import SchedulerService
                
                inicio_execucao = datetime.now(BRAZIL_TZ)
                scheduler = SchedulerService()
                resultado = scheduler.executor.executar_fila(limite_execucoes=pendentes_count)
                fim_execucao = datetime.now(BRAZIL_TZ)
                
                self.ultima_execucao_scheduler = agora
                
                # Calcular tempo de execuÃ§Ã£o
                tempo_execucao = (fim_execucao - inicio_execucao).total_seconds()
                
                logger.info(f"âœ… Scheduler executado - {resultado['total_executadas']} rotinas processadas em {tempo_execucao:.2f}s")
                
                # Log das prÃ³ximas execuÃ§Ãµes se houver
                if proxima_execucao:
                    logger.debug(f"PrÃ³xima rotina agendada: {proxima_execucao}")
            else:
                # Log discreto quando nÃ£o hÃ¡ rotinas pendentes
                if proxima_execucao:
                    logger.debug(f"Nenhuma rotina pendente. PrÃ³xima rotina agendada: {proxima_execucao}")
                else:
                    # NÃ£o precisamos logar toda vez que nÃ£o hÃ¡ rotinas pendentes nem agendadas
                    pass
                
        except Exception as e:
            logger.error(f"Erro na execuÃ§Ã£o do scheduler: {e}", exc_info=True)
            
    def _verificar_execucoes_imediatas(self):
        """Verifica e executa rotinas do minuto atual para maior precisÃ£o"""
        try:
            # Importar modelos
            from rotinas_automaticas.models import FilaExecucao
            
            # Obter hora atual com precisÃ£o de minuto
            agora = datetime.now(BRAZIL_TZ)
            hora_atual_str = agora.strftime('%H:%M')
            hora_atual_time = datetime.strptime(hora_atual_str, '%H:%M').time()
            
            # Verificar rotinas do minuto atual com precisÃ£o
            rotinas_do_minuto = FilaExecucao.objects.filter(
                status='PENDENTE',
                data_execucao=agora.date(),
                horario_execucao__hour=agora.hour,
                horario_execucao__minute=agora.minute
            )
            
            if rotinas_do_minuto.exists():
                logger.info(f"â° ExecuÃ§Ã£o imediata - Encontradas {rotinas_do_minuto.count()} rotina(s) para {hora_atual_str}")
                
                # Listar as rotinas para depuraÃ§Ã£o
                for item in rotinas_do_minuto:
                    logger.info(f"â° Executando imediatamente: {item.scheduler_rotina.rotina_definicao.nome_exibicao} ({item.horario_execucao})")
                
                # Executar diretamente sem aguardar o scheduler normal
                from rotinas_automaticas.scheduler_services import ExecutorRotinas
                executor = ExecutorRotinas()
                
                # Executar cada rotina individualmente para garantir execuÃ§Ã£o
                for item in rotinas_do_minuto:
                    try:
                        resultado = executor._executar_rotina(item)
                        status = "âœ… Sucesso" if resultado["sucesso"] else "âŒ Erro"
                        logger.info(f"{status} na execuÃ§Ã£o imediata: {item.scheduler_rotina.rotina_definicao.nome_exibicao}")
                    except Exception as e:
                        logger.error(f"Erro na execuÃ§Ã£o imediata: {e}", exc_info=True)
        except Exception as e:
            logger.error(f"Erro na verificaÃ§Ã£o de execuÃ§Ãµes imediatas: {e}", exc_info=True)
    
    def _verificar_saude_sistema(self):
        """Verifica saÃºde geral do sistema"""
        try:
            agora = datetime.now(BRAZIL_TZ)
            
            from rotinas_automaticas.models import FilaExecucao, CargaDiariaRotinas, SchedulerRotina
            from django.db import connection
            from django.utils import timezone
            from datetime import timedelta
            
            # EstatÃ­sticas gerais
            total_fila = FilaExecucao.objects.count()
            pendentes = FilaExecucao.objects.filter(status='PENDENTE').count()
            erros = FilaExecucao.objects.filter(status='ERRO').count()
            recovery = FilaExecucao.objects.filter(status='RECOVERY').count()
            executando = FilaExecucao.objects.filter(status='EXECUTANDO').count()
            
            # Verificar execuÃ§Ãµes travadas (executando hÃ¡ mais de 1 hora)
            hora_atras = timezone.now() - timedelta(hours=1)
            executando_travadas = FilaExecucao.objects.filter(
                status='EXECUTANDO',
                iniciado_em__lt=hora_atras
            ).count()
            
            # Verificar carga diÃ¡ria de hoje
            carga_hoje = CargaDiariaRotinas.objects.filter(
                data_carga=agora.date()
            ).first()
            
            # Rotinas ativas
            rotinas_ativas = SchedulerRotina.objects.filter(executar=True).count()
            
            # Verificar conexÃµes do banco
            conexoes_abertas = len(connection.connection.notices) if hasattr(connection, 'connection') and hasattr(connection.connection, 'notices') else 0
            
            # Verificar uso de memÃ³ria nÃ£o Ã© necessÃ¡rio para o funcionamento principal
            # e psutil nÃ£o Ã© uma dependÃªncia obrigatÃ³ria
            
            logger.info(f"ðŸ’Š VerificaÃ§Ã£o de saÃºde - {agora.strftime('%d/%m/%Y %H:%M')}")
            logger.info(f"   Fila: {total_fila} total, {pendentes} pendentes, {executando} executando, {erros} erros, {recovery} recovery")
            logger.info(f"   Carga hoje: {'âœ…' if carga_hoje else 'âŒ'}")
            logger.info(f"   Rotinas ativas: {rotinas_ativas}")
            logger.info(f"   Monitor ativo hÃ¡: {(agora - self.ultima_renovacao_diaria).total_seconds() / 3600:.1f} horas" if self.ultima_renovacao_diaria else "   Monitor iniciado recentemente")
            
            # Alertas
            if not carga_hoje:
                logger.warning("âš ï¸  ALERTA: Carga diÃ¡ria nÃ£o encontrada para hoje")
                
            if erros > 5:
                logger.warning(f"âš ï¸  ALERTA: {erros} rotinas com erro")
                
            if recovery > 3:
                logger.warning(f"âš ï¸  ALERTA: {recovery} rotinas em recovery")
                
            if executando_travadas > 0:
                logger.warning(f"âš ï¸  ALERTA: {executando_travadas} rotinas parecem estar travadas (executando hÃ¡ mais de 1 hora)")
                
            if pendentes > 20:
                logger.warning(f"âš ï¸  ALERTA: AcÃºmulo de {pendentes} rotinas pendentes")
                
        except Exception as e:
            logger.error(f"Erro na verificaÃ§Ã£o de saÃºde: {e}", exc_info=True)
            
    def _verificar_rotinas_travadas(self):
        """Verifica e corrige rotinas que ficaram travadas em execuÃ§Ã£o"""
        try:
            from rotinas_automaticas.scheduler_services import ExecutorRotinas
            
            # Verificar rotinas travadas hÃ¡ mais de 1 hora
            executor = ExecutorRotinas()
            resultado = executor.verificar_rotinas_travadas(limite_horas=1)
            
            if resultado['total_rotinas_travadas'] > 0:
                rotinas = [f"{r['nome']} ({r['duracao_minutos']:.1f} min)" for r in resultado['rotinas_corrigidas']]
                logger.warning(f"ðŸ”„ Corrigidas {resultado['total_rotinas_travadas']} rotinas travadas: {', '.join(rotinas)}")
            
        except Exception as e:
            logger.error(f"Erro na verificaÃ§Ã£o de rotinas travadas: {e}", exc_info=True)

# InstÃ¢ncia global do monitor
monitor_global = None

def iniciar_monitor():
    """Inicia o monitor global"""
    global monitor_global
    
    if monitor_global is None:
        monitor_global = SchedulerMonitor()
        
    if not monitor_global.running:
        monitor_global.start()
        return True
    return False

def parar_monitor():
    """Para o monitor global"""
    global monitor_global
    
    if monitor_global and monitor_global.running:
        monitor_global.stop()
        return True
    return False

def status_monitor():
    """Retorna status do monitor"""
    global monitor_global
    
    if monitor_global and monitor_global.running:
        return {
            'ativo': True,
            'ultima_execucao_scheduler': monitor_global.ultima_execucao_scheduler,
            'ultima_renovacao_diaria': monitor_global.ultima_renovacao_diaria
        }
    return {'ativo': False}
